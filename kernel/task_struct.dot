/*
node
color: naveblue, skyblue, red, red4, crimson, forestgreen, limegreen
style: solid, dotted, dashed, bold, rounded, filled
shape: box, polygon, ellipse, plaintext
*/

/*
edge
color: naveblue, skyblue, red, red4, crimson, forestgreen, limegreen
style: solid, dotted, dashed, bold
*/

/*
rankdir: TB BT LR RL
*/

/*
digraph example{
	fontname = "Verdana";
	fontsize = 10;
	rankdir=TB;

	node [fontname = "Verdana", fontsize = 10, color="skyblue", shape="record"];
	edge [fontname = "Verdana", fontsize = 10, color="crimson", style="solid"];

	st_hash_type [label="{<head>st_hash_type|(*compare)|(*hash)}"];
	st_table_entry [label="{<head>st_table_entry|hash|key|record|<next>next}"];
	st_table [label="{st_table|<type>type|num_bins|num_entries|<bins>bins}"];

	st_table:bins -> st_table_entry:head;
	st_table:type -> st_hash_type:head;
	st_table_entry:next -> st_table_entry:head [style="dashed", color="forestgreen"];
}
*/
/*
digraph input_subsystem{
	fontname = "Verdana";
	fontsize = 10;
	rankdir=TB;

	node [fontname = "Verdana", fontsize = 10, color="skyblue", shape="record"];
	edge [fontname = "Verdana", fontsize = 10, color="crimson", style="solid"];

	{rank=same;input_devA input_devB}
	{rank=same;input_handlerA input_handlerB}
	input_dev_list[style="dashed"]
	input_devA[label="{<head>input_dev|<s_node>node|<h_list>h_list}"];
	input_devB[label="{<head>input_dev|<s_node>node|<h_list>h_list}"];
	input_handle [label="{<head>input_handle|||<d_node>d_node|<s_dev>dev|<s_handler>handler|<h_node>h_node}"];
	input_handlerA [label="{<head>input_handler||||<h_list>h_list}"];
	input_handlerB [label="{<head>input_handler||||<h_list>hlist}"];
	input_handler_list[style="dashed"]

	input_dev_list->input_devA:s_node[dir="both"]
	input_dev_list->input_devB:s_node[dir="both"]
	//input_devA:s_node->input_devB:s_node[dir="both", style="dotted", constraint=false]
	input_devA:h_list->input_handle:d_node[dir="both", style="dashed"]
	input_handle:s_dev->input_devA:head
	input_handle:s_handler->input_handlerA:head
	input_handlerA:h_list->input_handle:h_node[dir="both", style="dashed"]
	input_handler_list->input_handlerA:head
	input_handler_list->input_handlerB

	//{rank=same; input_dev_list input_handler_list}
	//{rank=same; input_devA input_devB}
	//{rank=same; input_handlerA:head input_handlerB:head}

}
*/
digraph task{
	fontname = "Verdana";
	fontsize = 10;
	rankdir=TB;

	node [fontname = "Verdana", fontsize = 10, color="skyblue", shape="record"];
	edge [fontname = "Verdana", fontsize = 10, color="crimson", style="solid"];

	
	thread_info[label="{\
<head>struct thread_info\{\}|\
unsigned long flags|\
int preempt_count\n(0 preemptable, \<0  bug)|\
mm_segment_t addr_limit|\
<s_task_struct>struct task_struct* task|\
struct exec_domain *exec_domain\n__u32 cpu\n__u32 cpu_domain|\
<s_cpu_context>struct cpu_context_save cpu_context|..\
}"];

	task_struct[label="{\
<head>struct task_struct\{\}|\
<s_state>volatile long state|\
<s_stack>void *stack|\
unsigned int flags|..|\
int prio, static_prio, normal_prio\n\
unsigned int rt_priority\n\
const struct sched_class *sched_class\n\
struct sched_entity se\n\
struct sched_rt_entity rt|..|\
<s_tasks>struct list_head tasks|\
struct mm_struct *mm, *active_mm|..|\
pid_t pid\n\
pid_t tgid|..|\
<s_task_tree>struct task_struct *real_parent\nstruct task_struct *parent\nstruct list_head children\nstruct list_head sibling\nstruct task_struct *group_leader|\
<s_thread_group>struct pid_link pids[PIDTYPE_MAX]\nstruct list_head thread_group|..\
}"];

	thread_info:s_task_struct->task_struct:head; /*current_thread_info()->task, for_each_process(p)*/
	task_struct:s_stack->thread_info:head;

	task_struct:s_tasks->"list_add_tail_rcu(&p->tasks, &init_task.tasks)\n(copy_process())"[dir="both"]
	task_struct:s_thread_group->"list_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group)\n(copy_process())"[dir="both"]
}
